{-# LANGUAGE CPP #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
{-# HLINT ignore "Replace case with maybe" #-}

module TestLib.NixRendering where

import Data.Aeson as A
import Data.String.Interpolate
import Data.Text
import qualified Data.Text as T
import qualified Data.Vector as V
import TestLib.NixTypes

#if MIN_VERSION_aeson(2,0,0)
import qualified Data.Aeson.KeyMap          as HM
#else
import qualified Data.HashMap.Strict        as HM
#endif


renderNixEnvironment :: FilePath -> NixEnvironment -> Text
renderNixEnvironment bootstrapNixpkgs (NixEnvironment {..}) = [i|\# Autogenerated, please don't edit by hand

let
  bootstrapNixpkgs = import (#{bootstrapNixpkgs}) {};
  fetchgit = bootstrapNixpkgs.fetchgit;
  fetchFromGitHub = bootstrapNixpkgs.fetchFromGitHub;
  runCommand = bootstrapNixpkgs.runCommand;
  lib = bootstrapNixpkgs.lib;

  channels = rec {
#{T.intercalate "\n\n" [indentTo 4 $ renderChannel x | x <- nixEnvironmentChannels]}
  };

in

(import channels.codedown { inherit fetchFromGitHub; }).mkCodeDownEnvironment {
  inherit channels;

  kernels = [
#{T.intercalate "\n" [indentTo 4 $ renderKernel x | x <- nixEnvironmentKernels]}
  ];

  otherPackages = [
#{T.intercalate "\n" [indentTo 4 $ renderOtherPackage x | x <- nixEnvironmentOtherPackages]}
  ];
}
|]

renderChannel :: NixSrcSpec -> Text
renderChannel nixSrcSpec = [i|#{nixSrcName nixSrcSpec} = (#{renderNixSrcSpec nixSrcSpec});|]

renderNixSrcSpec :: NixSrcSpec -> Text
renderNixSrcSpec (NixSrcPath {..}) = nixSrcPath
renderNixSrcSpec (NixSrcFetchGit {..}) = [__i|fetchgit {
                                               url = "#{nixSrcUrl}";
                                               rev = "#{nixSrcRev}";
                                               sha256 = "#{nixSrcSha256}";
                                               #{maybeBranch}
                                             }|]
  where
    maybeBranch = case nixSrcBranchName of
      Nothing -> "" :: Text
      Just branch -> [i|ref = "#{branch}";|]
renderNixSrcSpec (NixSrcFetchFromGithub {..}) =
  [__i|fetchFromGitHub {
        owner = "#{nixSrcOwner}";
        repo = "#{nixSrcRepo}";
        rev = "#{nixSrcRev}";
        sha256 = "#{nixSrcSha256}";
      }|]

renderOtherPackage :: ChannelAndAttr -> Text
renderOtherPackage (ChannelAndAttr {..}) = [i|{ channel = "#{channelAndAttrChannel}"; attr = "#{channelAndAttrAttr}"; contents = importedChannels.#{channelAndAttrChannel}.#{channelAndAttrAttr};  }|]

renderKernel :: NixKernelSpec -> Text
renderKernel (NixKernelSpec {..}) = [i|({
  name = "#{nixKernelName}";
  channel = "#{nixKernelChannel}";
  args = {
    packages = [#{T.unwords $ fmap quote $ fmap nameAndMetaName nixKernelPackages}];#{settings}
  };
})|]
  where
    quote x = "\"" <> x <> "\""

    settings = maybe "" (("\n" <>) . indentTo 4 . (\x -> [i|settings = #{x};|]) . aesonToNix . A.Object) nixKernelSettings

aesonToNix :: A.Value -> Text
aesonToNix (A.Bool True) = "true"
aesonToNix (A.Bool False) = "false"
aesonToNix (A.Array xs) = "[" <> T.intercalate " " (fmap aesonToNix (V.toList xs)) <> "]"
aesonToNix (A.String s) = [i|''#{s}''|]
aesonToNix (A.Number n) = [i|#{n}|]
aesonToNix A.Null = [i|null|]
aesonToNix (A.Object os) = let
  ls = [[i|#{k} = #{aesonToNix v};|] | (k, v) <- HM.toList os]
    in [__i|{
              #{T.intercalate "\n" ls}
            }|]

indentTo :: Int -> Text -> Text
indentTo n = T.intercalate "\n" . fmap (space <>) . T.splitOn "\n"
  where space = T.replicate n " "
