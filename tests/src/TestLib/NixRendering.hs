{-# LANGUAGE CPP #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
{-# HLINT ignore "Replace case with maybe" #-}

module TestLib.NixRendering where

import Data.Aeson as A
import Data.Function
import Data.String.Interpolate
import Data.Text
import qualified Data.Text as T
import qualified Data.Vector as V
import TestLib.NixTypes

#if MIN_VERSION_aeson(2,0,0)
import qualified Data.Aeson.KeyMap as HM
#else
import qualified Data.HashMap.Strict as HM
#endif


renderNixEnvironment :: FilePath -> NixEnvironment -> Text
renderNixEnvironment bootstrapNixpkgs (NixEnvironment {..}) = [i|\# Autogenerated, please don't edit by hand

let
  bootstrapNixpkgs = import (#{bootstrapNixpkgs}) {};
  fetchgit = bootstrapNixpkgs.fetchgit;
  fetchFromGitHub = bootstrapNixpkgs.fetchFromGitHub;
  runCommand = bootstrapNixpkgs.runCommand;
  lib = bootstrapNixpkgs.lib;

  channels = rec {
#{T.intercalate "\n\n" [indentTo 4 $ renderChannel x | x <- nixEnvironmentChannels]}
  };

  importedChannels = lib.mapAttrs (name: value: let imported = import value; in
    if (builtins.isFunction imported) then bootstrapNixpkgs.callPackage imported {}
    else imported
  ) channels;

in

(import channels.codedown { inherit fetchFromGitHub; }).makeEnvironment {
#{T.intercalate "\n\n" [renderKernel x | x <- nixEnvironmentKernels]}

#{T.intercalate "\n" [t | t <- nixEnvironmentOtherConfig]}
}
|]

-- #{T.intercalate "\n" [indentTo 4 $ renderOtherPackage x | x <- nixEnvironmentOtherPackages]}

renderChannel :: NixSrcSpec -> Text
renderChannel nixSrcSpec = [i|#{nixSrcName nixSrcSpec} = (#{renderNixSrcSpec nixSrcSpec});|]

renderNixSrcSpec :: NixSrcSpec -> Text
renderNixSrcSpec (NixSrcPath {..}) = nixSrcPath
renderNixSrcSpec (NixSrcFetchGit {..}) = [__i|fetchgit {
                                               url = "#{nixSrcUrl}";
                                               rev = "#{nixSrcRev}";
                                               sha256 = "#{nixSrcSha256}";
                                               #{maybeBranch}
                                             }|]
  where
    maybeBranch = case nixSrcBranchName of
      Nothing -> "" :: Text
      Just branch -> [i|ref = "#{branch}";|]
renderNixSrcSpec (NixSrcFetchFromGithub {..}) =
  [__i|fetchFromGitHub {
        owner = "#{nixSrcOwner}";
        repo = "#{nixSrcRepo}";
        rev = "#{nixSrcRev}";
        sha256 = "#{nixSrcSha256}";
      }|]

renderOtherPackage :: ChannelAndAttr -> Text
renderOtherPackage (ChannelAndAttr {..}) = [i|{ channel = "#{channelAndAttrChannel}"; attr = "#{channelAndAttrAttr}"; contents = importedChannels.#{channelAndAttrChannel}.#{channelAndAttrAttr};  }|]

renderKernel :: NixKernelSpec -> Text
renderKernel (NixKernelSpec {..}) =
  [i|kernels.#{nixKernelName}.enable = true;|]
  <> kernelPackages
  <> kernelSettings
  where
    kernelPackages = case nixKernelPackages of
      [] -> ""
      xs -> [i|kernels.#{nixKernelName}.packages = [#{T.unwords $ fmap renderKernelPackage xs}];|]

    renderKernelPackage (NameAndSettings name Nothing) = quote name
    renderKernelPackage (NameAndSettings name (Just settings)) = aesonToNix (A.object (("name", A.String name) : HM.toList settings))
      & parenQuote

    parenQuote x = "(" <> x <> ")"

    quote x = "\"" <> x <> "\""

    kernelSettings :: Text
    kernelSettings = case nixKernelExtraConfig of
      Nothing -> ""
      Just [] -> ""
      Just xs -> "\n" <> T.intercalate "\n" (fmap (\x -> [i|kernels.#{nixKernelName}.#{x};|]) xs)

aesonToNix :: A.Value -> Text
aesonToNix (A.Bool True) = "true"
aesonToNix (A.Bool False) = "false"
aesonToNix (A.Array xs) = "[" <> T.intercalate " " (fmap aesonToNix (V.toList xs)) <> "]"
aesonToNix (A.String s) = [i|''#{s}''|]
aesonToNix (A.Number n) = [i|#{n}|]
aesonToNix A.Null = [i|null|]
aesonToNix (A.Object os) = let
  ls = [[i|#{k} = #{aesonToNix v};|] | (k, v) <- HM.toList os]
    in [__i|{
              #{T.intercalate "\n" ls}
            }|]

indentTo :: Int -> Text -> Text
indentTo n = T.intercalate "\n" . fmap (space <>) . T.splitOn "\n"
  where space = T.replicate n " "
